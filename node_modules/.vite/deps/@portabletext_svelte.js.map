{
  "version": 3,
  "sources": ["../../@portabletext/toolkit/src/asserters.ts", "../../@portabletext/toolkit/src/sortMarksByOccurences.ts", "../../@portabletext/toolkit/src/buildMarksTree.ts", "../../@portabletext/toolkit/src/nestLists.ts", "../../@portabletext/toolkit/src/spanToPlainText.ts", "../../@portabletext/toolkit/src/toPlainText.ts", "../../@portabletext/toolkit/src/types.ts", "../../@portabletext/svelte/dist/assertBlockKey.js", "../../@portabletext/svelte/dist/defaultComponents/DefaultMark.svelte", "../../@portabletext/svelte/dist/defaultComponents/DefaultLink.svelte", "../../@portabletext/svelte/dist/defaultComponents/DefaultBlock.svelte", "../../@portabletext/svelte/dist/defaultComponents/DefaultList.svelte", "../../@portabletext/svelte/dist/defaultComponents/DefaultListItem.svelte", "../../@portabletext/svelte/dist/defaultComponents/DefaultHardBreak.svelte", "../../@portabletext/svelte/dist/defaultComponents/UnknownType.svelte", "../../@portabletext/svelte/dist/defaultComponents/defaultComponents.js", "../../@portabletext/svelte/dist/defaultComponents/mergeComponents.js", "../../@portabletext/svelte/dist/renderers/RenderBlock.svelte", "../../@portabletext/svelte/dist/renderers/RenderCustomBlock.svelte", "../../@portabletext/svelte/dist/renderers/RenderList.svelte", "../../@portabletext/svelte/dist/renderers/RenderListItem.svelte", "../../@portabletext/svelte/dist/renderers/RenderSpan.svelte", "../../@portabletext/svelte/dist/renderers/RenderText.svelte", "../../@portabletext/svelte/dist/RenderNode.svelte", "../../@portabletext/svelte/dist/warnings.js", "../../@portabletext/svelte/dist/PortableText.svelte"],
  "sourcesContent": ["import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan,\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject,\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      !node.markDefs ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject,\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList,\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan,\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode,\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n", "import type {PortableTextSpan, TypedObject} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[],\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U,\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>,\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children, markDefs = []} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text})),\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n", "import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct',\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html',\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html',\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode,\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList,\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode,\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>,\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n", "import {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\nimport type {ToolkitNestedPortableTextSpan} from './types'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n", "import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\n\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /^\\s/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[],\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem\n  extends PortableTextListItemBlock<\n    PortableTextMarkDefinition,\n    PortableTextSpan | ToolkitPortableTextList\n  > {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition,\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (\n    | ToolkitTextNode\n    | ToolkitNestedPortableTextSpan<PortableTextMarkDefinition>\n    | ArbitraryTypedObject\n  )[]\n}\n", "function getRandomKey() {\n    return Math.random().toFixed(5).split('.')[1];\n}\nfunction assertSpanKey(span) {\n    return {\n        _key: span._key || getRandomKey(),\n        ...span\n    };\n}\nexport default function assertBlockKey(block) {\n    return {\n        _key: block._key || getRandomKey(),\n        ...block,\n        ...(block._type === 'block' && Array.isArray(block.children)\n            ? {\n                children: block.children.map(assertSpanKey)\n            }\n            : {})\n    };\n}\n", "<script>export let portableText;\n$:\n  ({ markType } = portableText);\n</script>\n\n{#if markType === 'strong'}\n  <strong>\n    <slot />\n  </strong>\n{:else if markType === 'em'}\n  <em>\n    <slot />\n  </em>\n{:else if markType === 'code'}\n  <code>\n    <slot />\n  </code>\n{:else if markType === 'underline'}\n  <span style=\"text-decoration:underline;\">\n    <slot />\n  </span>\n{:else if markType === 'strike-through'}\n  <del>\n    <slot />\n  </del>\n{:else}\n  <slot />\n{/if}\n", "<script>export let portableText;\n$:\n  ({ value } = portableText);\n$:\n  href = value?.href || value?.url || value?.link || value?.value;\n</script>\n\n{#if typeof href === 'string'}\n  <a {href}><slot /></a>\n{:else}\n  <slot />\n{/if}\n", "<script>export let portableText;\n$:\n  ({ value } = portableText);\n$:\n  style = value.style || \"normal\";\n</script>\n\n{#if ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote'].includes(style)}\n  <svelte:element this={style}><slot /></svelte:element>\n{:else if style === 'normal'}\n  <p><slot /></p>\n{:else}\n  <slot />\n{/if}\n", "<script>export let portableText;\n$:\n  ({ value } = portableText);\n$:\n  ({ listItem } = value);\n</script>\n\n{#if listItem === 'number'}\n  <ol><slot /></ol>\n{:else}\n  <ul><slot /></ul>\n{/if}\n", "<li><slot /></li>\n", "<br />\n", "import 'svelte/internal/disclose-version';\nimport 'svelte/internal/flags/legacy';\n\nUnknownType[$.FILENAME] = 'node_modules/@portabletext/svelte/dist/defaultComponents/UnknownType.svelte';\n\nimport * as $ from 'svelte/internal/client';\n\nfunction UnknownType($$anchor, $$props) {\n\t$.check_target(new.target);\n\t$.push($$props, false, UnknownType);\n\n\tvar $$exports = { ...$.legacy_api() };\n\tvar fragment = $.comment();\n\tvar node = $.first_child(fragment);\n\n\t$.slot(node, $$props, 'default', {}, null);\n\t$.append($$anchor, fragment);\n\n\treturn $.pop($$exports);\n}\n\nif (import.meta.hot) {\n\tUnknownType = $.hmr(UnknownType);\n\n\timport.meta.hot.accept((module) => {\n\t\tUnknownType[$.HMR].update(module.default);\n\t});\n}\n\nexport default UnknownType;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVW5rbm93blR5cGUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzbG90IC8+XG4iXSwibWFwcGluZ3MiOiIiLCJpZ25vcmVMaXN0IjpbXX0=", "import DefaultMark from './DefaultMark.svelte';\nimport DefaultLink from './DefaultLink.svelte';\nimport DefaultBlock from './DefaultBlock.svelte';\nimport DefaultList from './DefaultList.svelte';\nimport DefaultListItem from './DefaultListItem.svelte';\nimport DefaultHardBreak from './DefaultHardBreak.svelte';\nimport UnknownType from './UnknownType.svelte';\nconst defaultComponents = {\n    marks: {\n        'strike-through': DefaultMark,\n        code: DefaultMark,\n        em: DefaultMark,\n        strong: DefaultMark,\n        underline: DefaultMark,\n        link: DefaultLink\n    },\n    block: {\n        blockquote: DefaultBlock,\n        h1: DefaultBlock,\n        h2: DefaultBlock,\n        h3: DefaultBlock,\n        h4: DefaultBlock,\n        h5: DefaultBlock,\n        h6: DefaultBlock,\n        normal: DefaultBlock\n    },\n    list: {\n        bullet: DefaultList,\n        number: DefaultList\n    },\n    listItem: {\n        bullet: DefaultListItem,\n        number: DefaultListItem\n    },\n    types: {},\n    hardBreak: DefaultHardBreak,\n    unknownBlockStyle: DefaultBlock,\n    unknownList: DefaultList,\n    unknownListItem: DefaultListItem,\n    unknownMark: DefaultMark,\n    unknownType: UnknownType\n};\nexport default defaultComponents;\n", "export function mergeComponents(parent, overrides = {}) {\n    return {\n        ...parent,\n        ...overrides,\n        block: mergeDeeply(parent, overrides, 'block'),\n        list: mergeDeeply(parent, overrides, 'list'),\n        listItem: mergeDeeply(parent, overrides, 'listItem'),\n        marks: mergeDeeply(parent, overrides, 'marks'),\n        types: mergeDeeply(parent, overrides, 'types')\n    };\n}\n/**\n * As some components can be single functions, we can't simply spread them as objects\n */\nfunction mergeDeeply(parent, overrides, key) {\n    const override = overrides[key];\n    const parentVal = parent[key];\n    if (typeof override === 'function') {\n        return override;\n    }\n    if (override && typeof parentVal === 'function') {\n        return override;\n    }\n    if (override) {\n        return { ...parentVal, ...override };\n    }\n    return parentVal;\n}\n", "<script>export let global;\n$:\n  ({ components } = global);\nexport let node;\nexport let indexInParent;\n$:\n  ({ style = \"normal\" } = node);\n$:\n  blockComponent = typeof components.block === \"function\" ? components.block : components.block[style];\n$:\n  if (!blockComponent) {\n    global.missingComponentHandler(style, \"blockStyle\");\n  }\n$:\n  blockProps = /* @__PURE__ */ (() => {\n    return {\n      global,\n      indexInParent,\n      value: node\n    };\n  })();\n</script>\n\n<svelte:component this={blockComponent || components.unknownBlockStyle} portableText={blockProps}>\n  <slot />\n</svelte:component>\n", "<script>export let global;\n$:\n  ({ components } = global);\nexport let node;\nexport let parentBlock;\nexport let indexInParent;\nexport let isInline = false;\n$:\n  ({ _type } = node);\n$:\n  customComponent = components.types[_type];\n$:\n  if (!customComponent) {\n    global.missingComponentHandler(_type, \"block\");\n  }\n$:\n  componentProps = /* @__PURE__ */ (() => {\n    return {\n      global,\n      value: node,\n      indexInParent,\n      parentBlock,\n      isInline\n    };\n  })();\n</script>\n\n<svelte:component this={customComponent || components.unknownType} portableText={componentProps} />\n", "<script>export let global;\n$:\n  ({ components } = global);\nexport let indexInParent;\nexport let node;\n$:\n  ({ listItem } = node);\n$:\n  handler = typeof components.list === \"function\" ? components.list : components.list[listItem];\n$:\n  listComponent = handler;\n$:\n  if (!listComponent) {\n    global.missingComponentHandler(listItem, \"listStyle\");\n  }\n$:\n  listProps = /* @__PURE__ */ (() => {\n    return {\n      global,\n      value: node,\n      indexInParent\n    };\n  })();\n</script>\n\n<svelte:component this={listComponent || components.unknownList} portableText={listProps}>\n  <slot />\n</svelte:component>\n", "<script>export let global;\n$:\n  ({ components } = global);\nexport let indexInParent;\nexport let node;\n$:\n  ({ style = \"normal\" } = node);\n$:\n  listItemComponent = typeof components.listItem === \"function\" ? components.listItem : components.listItem[style];\n$:\n  if (!listItemComponent) {\n    global.missingComponentHandler(style, \"listItemStyle\");\n  }\n$:\n  styleComponent = style !== \"normal\" ? components.block[style] : void 0;\n$:\n  listItemProps = /* @__PURE__ */ (() => {\n    return {\n      global,\n      value: node,\n      indexInParent\n    };\n  })();\n</script>\n\n<svelte:component\n  this={listItemComponent || components.unknownListItem}\n  portableText={listItemProps}\n>\n  {#if styleComponent}\n    <svelte:component\n      this={styleComponent}\n      portableText={{\n        // Different props for the block that will hold this list\n        ...listItemProps,\n        value: {\n          ...node,\n          // BlockComponentProps shouldn't receive a listItem\n          listItem: undefined\n        }\n      }}\n    >\n      <slot />\n    </svelte:component>\n  {:else}\n    <slot />\n  {/if}\n</svelte:component>\n", "<script>import { spanToPlainText } from \"@portabletext/toolkit\";\nexport let global;\n$:\n  ({ components } = global);\nexport let node;\nexport let parentBlock;\n$:\n  ({ markType } = node);\n$:\n  markComponent = components.marks[markType];\n$:\n  if (!markComponent) {\n    global.missingComponentHandler(markType, \"mark\");\n  }\n$:\n  markProps = (() => {\n    return {\n      global,\n      parentBlock,\n      markType,\n      value: node.markDef,\n      markKey: node.markKey,\n      plainTextContent: spanToPlainText(node)\n    };\n  })();\n</script>\n\n<svelte:component this={markComponent || components.unknownMark} portableText={markProps}>\n  <slot />\n</svelte:component>\n", "<script>export let global;\n$:\n  ({ components } = global);\nexport let node;\n$:\n  ({ text } = node);\n</script>\n\n{#if text === '\\n'}\n  {#if typeof components.hardBreak === 'function'}\n    <svelte:component this={components.hardBreak} />\n  {:else}\n    {text}\n  {/if}\n{:else}\n  {text}\n{/if}\n", "<script>import {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode\n} from \"@portabletext/toolkit\";\nimport RenderBlock from \"./renderers/RenderBlock.svelte\";\nimport RenderCustomBlock from \"./renderers/RenderCustomBlock.svelte\";\nimport RenderList from \"./renderers/RenderList.svelte\";\nimport RenderListItem from \"./renderers/RenderListItem.svelte\";\nimport RenderSpan from \"./renderers/RenderSpan.svelte\";\nimport RenderText from \"./renderers/RenderText.svelte\";\nexport let global;\nexport let options;\n$:\n  ({ node, indexInParent, parentBlock, isInline } = options);\n</script>\n\n{#if isPortableTextToolkitList(node)}\n  <RenderList {node} {indexInParent} {global}>\n    {#each node.children as child, childIndex}\n      <svelte:self\n        options={{\n          node: child,\n          indexInParent: childIndex,\n          // The list's children will be parsed as PortableTextListItem, which will pass the proper parentBlock & isInline\n          parentBlock: undefined,\n          isInline: undefined\n        }}\n        {global}\n      />\n    {/each}\n  </RenderList>\n{:else if isPortableTextListItemBlock(node)}\n  <RenderListItem {node} {indexInParent} {global}>\n    {#each buildMarksTree(node) as child, childIndex}\n      <svelte:self\n        options={{\n          // Pass the current listItem as a parentBlock\n          parentBlock: node,\n          node: child,\n          isInline: true,\n          indexInParent: childIndex\n        }}\n        {global}\n      />\n    {/each}\n  </RenderListItem>\n{:else if isPortableTextToolkitSpan(node)}\n  <RenderSpan {node} {parentBlock} {global}>\n    {#each node.children as child, childIndex}\n      <svelte:self\n        options={{\n          parentBlock,\n          node: child,\n          isInline: true,\n          indexInParent: childIndex\n        }}\n        {global}\n      />\n    {/each}\n  </RenderSpan>\n{:else if isPortableTextBlock(node)}\n  <RenderBlock {node} {indexInParent} {global}>\n    {#each buildMarksTree(node) as child, childIndex}\n      <svelte:self\n        options={{\n          parentBlock: node,\n          node: child,\n          isInline: true,\n          indexInParent: childIndex\n        }}\n        {global}\n      />\n    {/each}\n  </RenderBlock>\n{:else if isPortableTextToolkitTextNode(node)}\n  <RenderText {node} {global} />\n{:else if node}\n  <RenderCustomBlock {node} {parentBlock} {indexInParent} {isInline} {global} />\n{/if}\n", "const getTemplate = (type, prop) => `Unknown ${type}, specify a component for it in the \\`components${prop ? '.' : ''}${prop}\\` prop`;\nexport const getWarningMessage = (type, nodeType) => {\n    switch (nodeType) {\n        case 'block':\n            return getTemplate(`block type \"${type}\"`, 'types');\n        case 'blockStyle':\n            return getTemplate(`block style \"${type}\"`, 'block');\n        case 'listItemStyle':\n            return getTemplate(`list item style \"${type}\"`, 'listItem');\n        case 'listStyle':\n            return getTemplate(`list style \"${type}\"`, 'list');\n        case 'mark':\n            return getTemplate(`mark type \"${type}\"`, 'marks');\n        default:\n            return getTemplate('type');\n    }\n};\nexport function printWarning(message) {\n    console.warn(message);\n}\n", "<script>import { LIST_NEST_MODE_HTML, nestLists } from \"@portabletext/toolkit\";\nimport assertBlockKey from \"./assertBlockKey\";\nimport defaultComponents from \"./defaultComponents/defaultComponents\";\nimport { mergeComponents } from \"./defaultComponents/mergeComponents\";\nimport RenderNode from \"./RenderNode.svelte\";\nimport { getWarningMessage, printWarning } from \"./warnings\";\nexport let value = [];\nexport let components;\nexport let context = {};\nexport let onMissingComponent = true;\n$:\n  mergedComponents = mergeComponents(defaultComponents, components);\n$:\n  keyedBlocks = (Array.isArray(value) ? value : [value]).map(assertBlockKey);\n$:\n  blocks = nestLists(keyedBlocks, LIST_NEST_MODE_HTML);\n$:\n  missingComponentHandler = (type, nodeType) => {\n    if (onMissingComponent === false) {\n      return;\n    }\n    const message = getWarningMessage(type, nodeType);\n    if (typeof onMissingComponent === \"function\") {\n      onMissingComponent(message, { type, nodeType });\n      return;\n    }\n    printWarning(message);\n  };\n</script>\n\n{#each blocks as node, index (node._key)}\n  <RenderNode\n    global={{\n      components: mergedComponents,\n      missingComponentHandler,\n      context,\n      ptBlocks: blocks,\n      ptRawValue: value\n    }}\n    options={{\n      node,\n      isInline: false,\n      indexInParent: index\n    }}\n  />\n{/each}\n"],
  "mappings": "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",
  "names": ["isPortableTextSpan", "node", "_type", "text", "marks", "Array", "isArray", "every", "mark", "isPortableTextBlock", "markDefs", "def", "_key", "children", "child", "isPortableTextListItemBlock", "block", "listItem", "level", "isPortableTextToolkitList", "isPortableTextToolkitSpan", "span", "isPortableTextToolkitTextNode", "knownDecorators", "sortMarksByOccurences", "index", "blockChildren", "length", "slice", "occurences", "forEach", "siblingIndex", "sibling", "indexOf", "sort", "markA", "markB", "sortMarks", "aOccurences", "bOccurences", "aKnownPos", "bKnownPos", "localeCompare", "buildMarksTree", "_a", "sortedMarks", "map", "rootNode", "markType", "nodeStack", "i", "marksNeeded", "pos", "markKey", "splice", "currentNode", "markDef", "find", "push", "lines", "split", "line", "concat", "nestLists", "blocks", "mode", "tree", "currentList", "listFromBlock", "blockMatchesList", "newList", "lastListItem", "newLastChild", "_objectSpread", "matchingBranch", "match", "findListMatching", "console", "warn", "list", "matching", "style", "filterOnType", "spanToPlainText", "current", "leadingSpace", "trailingSpace", "toPlainText", "pad", "test", "LIST_NEST_MODE_HTML", "root_1", "root_3", "root_1", "root_2", "root", "$$anchor", "$$anchor", "$$anchor", "$$anchor", "$$component", "$$anchor", "text", "$$anchor", "$$anchor", "child", "prop", "$$anchor", "index"]
}
