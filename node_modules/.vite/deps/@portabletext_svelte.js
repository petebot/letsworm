import "./chunk-MZVN5SDE.js";
import {
  add_locations,
  check_target,
  component,
  each,
  element,
  hmr,
  if_block,
  index,
  init,
  legacy_api,
  prop,
  set_attribute,
  slot,
  validate_dynamic_element_tag,
  validate_void_dynamic_element,
  wrap_snippet
} from "./chunk-YARGJKVQ.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html,
  set_text,
  text
} from "./chunk-7TYJH4AB.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  deep_read_state,
  derived_safe_equal,
  fallback,
  first_child,
  get,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mutable_source,
  pop,
  push,
  reset,
  set,
  strict_equals,
  template_effect,
  untrack,
  user_derived
} from "./chunk-5IJ2R7KV.js";
import "./chunk-XWATFG4W.js";
import "./chunk-HNWPC2PS.js";
import "./chunk-MG2LXIFG.js";
import "./chunk-OHYQYV5R.js";
import "./chunk-XSCQBFM2.js";

// node_modules/@portabletext/toolkit/dist/index.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function isPortableTextSpan(node) {
  return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == "string"));
}
function isPortableTextBlock(node) {
  return (
    // A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    (!("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def) => typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child2) => typeof child2 == "object" && "_type" in child2)
  );
}
function isPortableTextListItemBlock(block) {
  return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem == "string" && (typeof block.level > "u" || typeof block.level == "number");
}
function isPortableTextToolkitList(block) {
  return block._type === "@list";
}
function isPortableTextToolkitSpan(span) {
  return span._type === "@span";
}
function isPortableTextToolkitTextNode(node) {
  return node._type === "@text";
}
var knownDecorators = ["strong", "em", "code", "underline", "strike-through"];
function sortMarksByOccurences(span, index2, blockChildren) {
  if (!isPortableTextSpan(span) || !span.marks) return [];
  if (!span.marks.length) return [];
  const marks = span.marks.slice(), occurences = {};
  return marks.forEach((mark) => {
    occurences[mark] = 1;
    for (let siblingIndex = index2 + 1; siblingIndex < blockChildren.length; siblingIndex++) {
      const sibling = blockChildren[siblingIndex];
      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;
      else break;
    }
  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
  const aOccurences = occurences[markA], bOccurences = occurences[markB];
  if (aOccurences !== bOccurences) return bOccurences - aOccurences;
  const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);
  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);
}
function buildMarksTree(block) {
  var _a;
  const {
    children,
    markDefs = []
  } = block;
  if (!children || !children.length) return [];
  const sortedMarks = children.map(sortMarksByOccurences), rootNode = {
    _type: "@span",
    children: [],
    markType: "<unknown>"
  };
  let nodeStack = [rootNode];
  for (let i = 0; i < children.length; i++) {
    const span = children[i];
    if (!span) continue;
    const marksNeeded = sortedMarks[i] || [];
    let pos = 1;
    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {
      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || "", index2 = marksNeeded.indexOf(mark);
      if (index2 === -1) break;
      marksNeeded.splice(index2, 1);
    }
    nodeStack = nodeStack.slice(0, pos);
    let currentNode = nodeStack[nodeStack.length - 1];
    if (currentNode) {
      for (const markKey of marksNeeded) {
        const markDef = markDefs.find((def) => def._key === markKey), markType = markDef ? markDef._type : markKey, node = {
          _type: "@span",
          _key: span._key,
          children: [],
          markDef,
          markType,
          markKey
        };
        currentNode.children.push(node), nodeStack.push(node), currentNode = node;
      }
      if (isPortableTextSpan(span)) {
        const lines = span.text.split(`
`);
        for (let line = lines.length; line-- > 1; ) lines.splice(line, 0, `
`);
        currentNode.children = currentNode.children.concat(lines.map((text2) => ({
          _type: "@text",
          text: text2
        })));
      } else currentNode.children = currentNode.children.concat(span);
    }
  }
  return rootNode.children;
}
function nestLists(blocks, mode) {
  const tree = [];
  let currentList;
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    if (block) {
      if (!isPortableTextListItemBlock(block)) {
        tree.push(block), currentList = void 0;
        continue;
      }
      if (!currentList) {
        currentList = listFromBlock(block, i, mode), tree.push(currentList);
        continue;
      }
      if (blockMatchesList(block, currentList)) {
        currentList.children.push(block);
        continue;
      }
      if ((block.level || 1) > currentList.level) {
        const newList = listFromBlock(block, i, mode);
        if (mode === "html") {
          const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {
            children: [...lastListItem.children, newList]
          });
          currentList.children[currentList.children.length - 1] = newLastChild;
        } else currentList.children.push(newList);
        currentList = newList;
        continue;
      }
      if ((block.level || 1) < currentList.level) {
        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);
        if (match) {
          currentList = match, currentList.children.push(block);
          continue;
        }
        currentList = listFromBlock(block, i, mode), tree.push(currentList);
        continue;
      }
      if (block.listItem !== currentList.listItem) {
        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, {
          level: block.level || 1
        });
        if (match && match.listItem === block.listItem) {
          currentList = match, currentList.children.push(block);
          continue;
        } else {
          currentList = listFromBlock(block, i, mode), tree.push(currentList);
          continue;
        }
      }
      console.warn("Unknown state encountered for block", block), tree.push(block);
    }
  }
  return tree;
}
function blockMatchesList(block, list) {
  return (block.level || 1) === list.level && block.listItem === list.listItem;
}
function listFromBlock(block, index2, mode) {
  return {
    _type: "@list",
    _key: `${block._key || `${index2}`}-parent`,
    mode,
    level: block.level || 1,
    listItem: block.listItem,
    children: [block]
  };
}
function findListMatching(rootNode, matching) {
  const level = matching.level || 1, style = matching.listItem || "normal", filterOnType = typeof matching.listItem == "string";
  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) return rootNode;
  if (!("children" in rootNode)) return;
  const node = rootNode.children[rootNode.children.length - 1];
  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
function spanToPlainText(span) {
  let text2 = "";
  return span.children.forEach((current) => {
    isPortableTextToolkitTextNode(current) ? text2 += current.text : isPortableTextToolkitSpan(current) && (text2 += spanToPlainText(current));
  }), text2;
}
var leadingSpace = /^\s/;
var trailingSpace = /^\s/;
function toPlainText(block) {
  const blocks = Array.isArray(block) ? block : [block];
  let text2 = "";
  return blocks.forEach((current, index2) => {
    if (!isPortableTextBlock(current)) return;
    let pad = false;
    current.children.forEach((span) => {
      isPortableTextSpan(span) ? (text2 += pad && text2 && !trailingSpace.test(text2) && !leadingSpace.test(span.text) ? " " : "", text2 += span.text, pad = false) : pad = true;
    }), index2 !== blocks.length - 1 && (text2 += `

`);
  }), text2;
}
var LIST_NEST_MODE_HTML = "html";

// node_modules/@portabletext/svelte/dist/assertBlockKey.js
function getRandomKey() {
  return Math.random().toFixed(5).split(".")[1];
}
function assertSpanKey(span) {
  return {
    _key: span._key || getRandomKey(),
    ...span
  };
}
function assertBlockKey(block) {
  return {
    _key: block._key || getRandomKey(),
    ...block,
    ...block._type === "block" && Array.isArray(block.children) ? {
      children: block.children.map(assertSpanKey)
    } : {}
  };
}

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultMark.svelte
DefaultMark[FILENAME] = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultMark.svelte";
var root_1 = add_locations(from_html(`<strong><!></strong>`), DefaultMark[FILENAME], [[7, 2]]);
var root_2 = add_locations(from_html(`<em><!></em>`), DefaultMark[FILENAME], [[11, 2]]);
var root_3 = add_locations(from_html(`<code><!></code>`), DefaultMark[FILENAME], [[15, 2]]);
var root_4 = add_locations(from_html(`<span style="text-decoration:underline;"><!></span>`), DefaultMark[FILENAME], [[19, 2]]);
var root_5 = add_locations(from_html(`<del><!></del>`), DefaultMark[FILENAME], [[23, 2]]);
function DefaultMark($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, DefaultMark);
  const markType = mutable_source();
  let portableText = prop($$props, "portableText", 8);
  legacy_pre_effect(() => (get(markType), deep_read_state(portableText())), () => {
    (($$value) => {
      set(markType, $$value.markType);
    })(portableText());
  });
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var strong = root_1();
      var node_1 = child(strong);
      slot(node_1, $$props, "default", {}, null);
      reset(strong);
      append($$anchor2, strong);
    };
    var consequent_1 = ($$anchor2) => {
      var em = root_2();
      var node_2 = child(em);
      slot(node_2, $$props, "default", {}, null);
      reset(em);
      append($$anchor2, em);
    };
    var consequent_2 = ($$anchor2) => {
      var code = root_3();
      var node_3 = child(code);
      slot(node_3, $$props, "default", {}, null);
      reset(code);
      append($$anchor2, code);
    };
    var consequent_3 = ($$anchor2) => {
      var span = root_4();
      var node_4 = child(span);
      slot(node_4, $$props, "default", {}, null);
      reset(span);
      append($$anchor2, span);
    };
    var consequent_4 = ($$anchor2) => {
      var del = root_5();
      var node_5 = child(del);
      slot(node_5, $$props, "default", {}, null);
      reset(del);
      append($$anchor2, del);
    };
    var alternate = ($$anchor2) => {
      var fragment_1 = comment();
      var node_6 = first_child(fragment_1);
      slot(node_6, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(get(markType), "strong")) $$render(consequent);
        else if (strict_equals(get(markType), "em")) $$render(consequent_1, 1);
        else if (strict_equals(get(markType), "code")) $$render(consequent_2, 2);
        else if (strict_equals(get(markType), "underline")) $$render(consequent_3, 3);
        else if (strict_equals(get(markType), "strike-through")) $$render(consequent_4, 4);
        else $$render(alternate, false);
      }),
      "if",
      DefaultMark,
      6,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DefaultMark = hmr(DefaultMark);
  import.meta.hot.accept((module) => {
    DefaultMark[HMR].update(module.default);
  });
}
var DefaultMark_default = DefaultMark;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultLink.svelte
DefaultLink[FILENAME] = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultLink.svelte";
var root_12 = add_locations(from_html(`<a><!></a>`), DefaultLink[FILENAME], [[9, 2]]);
function DefaultLink($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, DefaultLink);
  const value = mutable_source();
  const href = mutable_source();
  let portableText = prop($$props, "portableText", 8);
  legacy_pre_effect(() => (get(value), deep_read_state(portableText())), () => {
    (($$value) => {
      set(value, $$value.value);
    })(portableText());
  });
  legacy_pre_effect(() => get(value), () => {
    var _a, _b, _c, _d;
    set(href, ((_a = get(value)) == null ? void 0 : _a.href) || ((_b = get(value)) == null ? void 0 : _b.url) || ((_c = get(value)) == null ? void 0 : _c.link) || ((_d = get(value)) == null ? void 0 : _d.value));
  });
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var a = root_12();
      var node_1 = child(a);
      slot(node_1, $$props, "default", {}, null);
      reset(a);
      template_effect(() => set_attribute(a, "href", get(href)));
      append($$anchor2, a);
    };
    var alternate = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      slot(node_2, $$props, "default", {}, null);
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(typeof get(href), "string")) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      DefaultLink,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DefaultLink = hmr(DefaultLink);
  import.meta.hot.accept((module) => {
    DefaultLink[HMR].update(module.default);
  });
}
var DefaultLink_default = DefaultLink;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultBlock.svelte
DefaultBlock[FILENAME] = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultBlock.svelte";
var root_32 = add_locations(from_html(`<p><!></p>`), DefaultBlock[FILENAME], [[11, 2]]);
function DefaultBlock($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, DefaultBlock);
  const value = mutable_source();
  const style = mutable_source();
  let portableText = prop($$props, "portableText", 8);
  legacy_pre_effect(() => (get(value), deep_read_state(portableText())), () => {
    (($$value) => {
      set(value, $$value.value);
    })(portableText());
  });
  legacy_pre_effect(() => get(value), () => {
    set(style, get(value).style || "normal");
  });
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        validate_dynamic_element_tag(() => get(style));
        validate_void_dynamic_element(() => get(style));
        element(
          node_1,
          () => get(style),
          false,
          ($$element, $$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            slot(node_2, $$props, "default", {}, null);
            append($$anchor3, fragment_2);
          },
          void 0,
          [9, 2]
        );
      }
      append($$anchor2, fragment_1);
    };
    var d = user_derived(() => (get(style), untrack(() => ["h1", "h2", "h3", "h4", "h5", "h6", "blockquote"].includes(get(style)))));
    var consequent_1 = ($$anchor2) => {
      var p = root_32();
      var node_3 = child(p);
      slot(node_3, $$props, "default", {}, null);
      reset(p);
      append($$anchor2, p);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_4 = first_child(fragment_3);
      slot(node_4, $$props, "default", {}, null);
      append($$anchor2, fragment_3);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(d)) $$render(consequent);
        else if (strict_equals(get(style), "normal")) $$render(consequent_1, 1);
        else $$render(alternate, false);
      }),
      "if",
      DefaultBlock,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DefaultBlock = hmr(DefaultBlock);
  import.meta.hot.accept((module) => {
    DefaultBlock[HMR].update(module.default);
  });
}
var DefaultBlock_default = DefaultBlock;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultList.svelte
DefaultList[FILENAME] = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultList.svelte";
var root_13 = add_locations(from_html(`<ol><!></ol>`), DefaultList[FILENAME], [[9, 2]]);
var root_22 = add_locations(from_html(`<ul><!></ul>`), DefaultList[FILENAME], [[11, 2]]);
function DefaultList($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, DefaultList);
  const value = mutable_source();
  const listItem = mutable_source();
  let portableText = prop($$props, "portableText", 8);
  legacy_pre_effect(() => (get(value), deep_read_state(portableText())), () => {
    (($$value) => {
      set(value, $$value.value);
    })(portableText());
  });
  legacy_pre_effect(() => (get(listItem), get(value)), () => {
    (($$value) => {
      set(listItem, $$value.listItem);
    })(get(value));
  });
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var ol = root_13();
      var node_1 = child(ol);
      slot(node_1, $$props, "default", {}, null);
      reset(ol);
      append($$anchor2, ol);
    };
    var alternate = ($$anchor2) => {
      var ul = root_22();
      var node_2 = child(ul);
      slot(node_2, $$props, "default", {}, null);
      reset(ul);
      append($$anchor2, ul);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(get(listItem), "number")) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      DefaultList,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  DefaultList = hmr(DefaultList);
  import.meta.hot.accept((module) => {
    DefaultList[HMR].update(module.default);
  });
}
var DefaultList_default = DefaultList;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultListItem.svelte
DefaultListItem[FILENAME] = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultListItem.svelte";
var root = add_locations(from_html(`<li><!></li>`), DefaultListItem[FILENAME], [[1, 0]]);
function DefaultListItem($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, DefaultListItem);
  var $$exports = { ...legacy_api() };
  var li = root();
  var node = child(li);
  slot(node, $$props, "default", {}, null);
  reset(li);
  append($$anchor, li);
  return pop($$exports);
}
if (import.meta.hot) {
  DefaultListItem = hmr(DefaultListItem);
  import.meta.hot.accept((module) => {
    DefaultListItem[HMR].update(module.default);
  });
}
var DefaultListItem_default = DefaultListItem;

// node_modules/@portabletext/svelte/dist/defaultComponents/DefaultHardBreak.svelte
DefaultHardBreak[FILENAME] = "node_modules/@portabletext/svelte/dist/defaultComponents/DefaultHardBreak.svelte";
var root2 = add_locations(from_html(`<br/>`), DefaultHardBreak[FILENAME], [[1, 0]]);
function DefaultHardBreak($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, DefaultHardBreak);
  var $$exports = { ...legacy_api() };
  var br = root2();
  append($$anchor, br);
  return pop($$exports);
}
if (import.meta.hot) {
  DefaultHardBreak = hmr(DefaultHardBreak);
  import.meta.hot.accept((module) => {
    DefaultHardBreak[HMR].update(module.default);
  });
}
var DefaultHardBreak_default = DefaultHardBreak;

// node_modules/@portabletext/svelte/dist/defaultComponents/UnknownType.svelte
UnknownType[FILENAME] = "node_modules/@portabletext/svelte/dist/defaultComponents/UnknownType.svelte";
function UnknownType($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, UnknownType);
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  UnknownType = hmr(UnknownType);
  import.meta.hot.accept((module) => {
    UnknownType[HMR].update(module.default);
  });
}
var UnknownType_default = UnknownType;

// node_modules/@portabletext/svelte/dist/defaultComponents/defaultComponents.js
var defaultComponents = {
  marks: {
    "strike-through": DefaultMark_default,
    code: DefaultMark_default,
    em: DefaultMark_default,
    strong: DefaultMark_default,
    underline: DefaultMark_default,
    link: DefaultLink_default
  },
  block: {
    blockquote: DefaultBlock_default,
    h1: DefaultBlock_default,
    h2: DefaultBlock_default,
    h3: DefaultBlock_default,
    h4: DefaultBlock_default,
    h5: DefaultBlock_default,
    h6: DefaultBlock_default,
    normal: DefaultBlock_default
  },
  list: {
    bullet: DefaultList_default,
    number: DefaultList_default
  },
  listItem: {
    bullet: DefaultListItem_default,
    number: DefaultListItem_default
  },
  types: {},
  hardBreak: DefaultHardBreak_default,
  unknownBlockStyle: DefaultBlock_default,
  unknownList: DefaultList_default,
  unknownListItem: DefaultListItem_default,
  unknownMark: DefaultMark_default,
  unknownType: UnknownType_default
};
var defaultComponents_default = defaultComponents;

// node_modules/@portabletext/svelte/dist/defaultComponents/mergeComponents.js
function mergeComponents(parent, overrides = {}) {
  return {
    ...parent,
    ...overrides,
    block: mergeDeeply(parent, overrides, "block"),
    list: mergeDeeply(parent, overrides, "list"),
    listItem: mergeDeeply(parent, overrides, "listItem"),
    marks: mergeDeeply(parent, overrides, "marks"),
    types: mergeDeeply(parent, overrides, "types")
  };
}
function mergeDeeply(parent, overrides, key) {
  const override = overrides[key];
  const parentVal = parent[key];
  if (typeof override === "function") {
    return override;
  }
  if (override && typeof parentVal === "function") {
    return override;
  }
  if (override) {
    return { ...parentVal, ...override };
  }
  return parentVal;
}

// node_modules/@portabletext/svelte/dist/renderers/RenderBlock.svelte
RenderBlock[FILENAME] = "node_modules/@portabletext/svelte/dist/renderers/RenderBlock.svelte";
function RenderBlock($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, RenderBlock);
  const components = mutable_source();
  const style = mutable_source();
  const blockComponent = mutable_source();
  const blockProps = mutable_source();
  let global = prop($$props, "global", 8);
  let node = prop($$props, "node", 8);
  let indexInParent = prop($$props, "indexInParent", 8);
  legacy_pre_effect(() => (get(components), deep_read_state(global())), () => {
    (($$value) => {
      set(components, $$value.components);
    })(global());
  });
  legacy_pre_effect(() => (get(style), deep_read_state(node())), () => {
    (($$value) => {
      set(style, fallback($$value.style, "normal"));
    })(node());
  });
  legacy_pre_effect(() => (get(components), get(style)), () => {
    set(blockComponent, strict_equals(typeof get(components).block, "function") ? get(components).block : get(components).block[get(style)]);
  });
  legacy_pre_effect(
    () => (get(blockComponent), deep_read_state(global()), get(style)),
    () => {
      if (!get(blockComponent)) {
        global().missingComponentHandler(get(style), "blockStyle");
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(global()), deep_read_state(indexInParent()), deep_read_state(node())),
    () => {
      set(blockProps, (() => {
        return {
          global: global(),
          indexInParent: indexInParent(),
          value: node()
        };
      })());
    }
  );
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  add_svelte_meta(
    () => component(node_1, () => get(blockComponent) || get(components).unknownBlockStyle, ($$anchor2, $$component) => {
      $$component($$anchor2, {
        get portableText() {
          return get(blockProps);
        },
        children: wrap_snippet(RenderBlock, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    RenderBlock,
    24,
    0,
    { componentTag: "svelte:component" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RenderBlock = hmr(RenderBlock);
  import.meta.hot.accept((module) => {
    RenderBlock[HMR].update(module.default);
  });
}
var RenderBlock_default = RenderBlock;

// node_modules/@portabletext/svelte/dist/renderers/RenderCustomBlock.svelte
RenderCustomBlock[FILENAME] = "node_modules/@portabletext/svelte/dist/renderers/RenderCustomBlock.svelte";
function RenderCustomBlock($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, RenderCustomBlock);
  const components = mutable_source();
  const _type = mutable_source();
  const customComponent = mutable_source();
  const componentProps = mutable_source();
  let global = prop($$props, "global", 8);
  let node = prop($$props, "node", 8);
  let parentBlock = prop($$props, "parentBlock", 8);
  let indexInParent = prop($$props, "indexInParent", 8);
  let isInline = prop($$props, "isInline", 8, false);
  legacy_pre_effect(() => (get(components), deep_read_state(global())), () => {
    (($$value) => {
      set(components, $$value.components);
    })(global());
  });
  legacy_pre_effect(() => (get(_type), deep_read_state(node())), () => {
    (($$value) => {
      set(_type, $$value._type);
    })(node());
  });
  legacy_pre_effect(() => (get(components), get(_type)), () => {
    set(customComponent, get(components).types[get(_type)]);
  });
  legacy_pre_effect(
    () => (get(customComponent), deep_read_state(global()), get(_type)),
    () => {
      if (!get(customComponent)) {
        global().missingComponentHandler(get(_type), "block");
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(global()), deep_read_state(node()), deep_read_state(indexInParent()), deep_read_state(parentBlock()), deep_read_state(isInline())),
    () => {
      set(componentProps, (() => {
        return {
          global: global(),
          value: node(),
          indexInParent: indexInParent(),
          parentBlock: parentBlock(),
          isInline: isInline()
        };
      })());
    }
  );
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  add_svelte_meta(
    () => component(node_1, () => get(customComponent) || get(components).unknownType, ($$anchor2, $$component) => {
      $$component($$anchor2, {
        get portableText() {
          return get(componentProps);
        }
      });
    }),
    "component",
    RenderCustomBlock,
    28,
    0,
    { componentTag: "svelte:component" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RenderCustomBlock = hmr(RenderCustomBlock);
  import.meta.hot.accept((module) => {
    RenderCustomBlock[HMR].update(module.default);
  });
}
var RenderCustomBlock_default = RenderCustomBlock;

// node_modules/@portabletext/svelte/dist/renderers/RenderList.svelte
RenderList[FILENAME] = "node_modules/@portabletext/svelte/dist/renderers/RenderList.svelte";
function RenderList($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, RenderList);
  const components = mutable_source();
  const listItem = mutable_source();
  const handler = mutable_source();
  const listComponent = mutable_source();
  const listProps = mutable_source();
  let global = prop($$props, "global", 8);
  let indexInParent = prop($$props, "indexInParent", 8);
  let node = prop($$props, "node", 8);
  legacy_pre_effect(() => (get(components), deep_read_state(global())), () => {
    (($$value) => {
      set(components, $$value.components);
    })(global());
  });
  legacy_pre_effect(() => (get(listItem), deep_read_state(node())), () => {
    (($$value) => {
      set(listItem, $$value.listItem);
    })(node());
  });
  legacy_pre_effect(() => (get(components), get(listItem)), () => {
    set(handler, strict_equals(typeof get(components).list, "function") ? get(components).list : get(components).list[get(listItem)]);
  });
  legacy_pre_effect(() => get(handler), () => {
    set(listComponent, get(handler));
  });
  legacy_pre_effect(
    () => (get(listComponent), deep_read_state(global()), get(listItem)),
    () => {
      if (!get(listComponent)) {
        global().missingComponentHandler(get(listItem), "listStyle");
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(global()), deep_read_state(node()), deep_read_state(indexInParent())),
    () => {
      set(listProps, (() => {
        return {
          global: global(),
          value: node(),
          indexInParent: indexInParent()
        };
      })());
    }
  );
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  add_svelte_meta(
    () => component(node_1, () => get(listComponent) || get(components).unknownList, ($$anchor2, $$component) => {
      $$component($$anchor2, {
        get portableText() {
          return get(listProps);
        },
        children: wrap_snippet(RenderList, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    RenderList,
    26,
    0,
    { componentTag: "svelte:component" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RenderList = hmr(RenderList);
  import.meta.hot.accept((module) => {
    RenderList[HMR].update(module.default);
  });
}
var RenderList_default = RenderList;

// node_modules/@portabletext/svelte/dist/renderers/RenderListItem.svelte
RenderListItem[FILENAME] = "node_modules/@portabletext/svelte/dist/renderers/RenderListItem.svelte";
function RenderListItem($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, RenderListItem);
  const components = mutable_source();
  const style = mutable_source();
  const listItemComponent = mutable_source();
  const styleComponent = mutable_source();
  const listItemProps = mutable_source();
  let global = prop($$props, "global", 8);
  let indexInParent = prop($$props, "indexInParent", 8);
  let node = prop($$props, "node", 8);
  legacy_pre_effect(() => (get(components), deep_read_state(global())), () => {
    (($$value) => {
      set(components, $$value.components);
    })(global());
  });
  legacy_pre_effect(() => (get(style), deep_read_state(node())), () => {
    (($$value) => {
      set(style, fallback($$value.style, "normal"));
    })(node());
  });
  legacy_pre_effect(() => (get(components), get(style)), () => {
    set(listItemComponent, strict_equals(typeof get(components).listItem, "function") ? get(components).listItem : get(components).listItem[get(style)]);
  });
  legacy_pre_effect(
    () => (get(listItemComponent), deep_read_state(global()), get(style)),
    () => {
      if (!get(listItemComponent)) {
        global().missingComponentHandler(get(style), "listItemStyle");
      }
    }
  );
  legacy_pre_effect(() => (get(style), get(components)), () => {
    set(styleComponent, strict_equals(get(style), "normal", false) ? get(components).block[get(style)] : void 0);
  });
  legacy_pre_effect(
    () => (deep_read_state(global()), deep_read_state(node()), deep_read_state(indexInParent())),
    () => {
      set(listItemProps, (() => {
        return {
          global: global(),
          value: node(),
          indexInParent: indexInParent()
        };
      })());
    }
  );
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  add_svelte_meta(
    () => component(node_1, () => get(listItemComponent) || get(components).unknownListItem, ($$anchor2, $$component) => {
      $$component($$anchor2, {
        get portableText() {
          return get(listItemProps);
        },
        children: wrap_snippet(RenderListItem, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              {
                let $0 = derived_safe_equal(() => (get(listItemProps), deep_read_state(node()), untrack(() => ({
                  ...get(listItemProps),
                  value: { ...node(), listItem: void 0 }
                }))));
                add_svelte_meta(
                  () => component(node_3, () => get(styleComponent), ($$anchor5, $$component2) => {
                    $$component2($$anchor5, {
                      get portableText() {
                        return get($0);
                      },
                      children: wrap_snippet(RenderListItem, ($$anchor6, $$slotProps2) => {
                        var fragment_3 = comment();
                        var node_4 = first_child(fragment_3);
                        slot(node_4, $$props, "default", {}, null);
                        append($$anchor6, fragment_3);
                      }),
                      $$slots: { default: true }
                    });
                  }),
                  "component",
                  RenderListItem,
                  31,
                  4,
                  { componentTag: "svelte:component" }
                );
              }
              append($$anchor4, fragment_2);
            };
            var alternate = ($$anchor4) => {
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              slot(node_5, $$props, "default", {}, null);
              append($$anchor4, fragment_4);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if (get(styleComponent)) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              RenderListItem,
              30,
              2
            );
          }
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    RenderListItem,
    26,
    0,
    { componentTag: "svelte:component" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RenderListItem = hmr(RenderListItem);
  import.meta.hot.accept((module) => {
    RenderListItem[HMR].update(module.default);
  });
}
var RenderListItem_default = RenderListItem;

// node_modules/@portabletext/svelte/dist/renderers/RenderSpan.svelte
RenderSpan[FILENAME] = "node_modules/@portabletext/svelte/dist/renderers/RenderSpan.svelte";
function RenderSpan($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, RenderSpan);
  const components = mutable_source();
  const markType = mutable_source();
  const markComponent = mutable_source();
  const markProps = mutable_source();
  let global = prop($$props, "global", 8);
  let node = prop($$props, "node", 8);
  let parentBlock = prop($$props, "parentBlock", 8);
  legacy_pre_effect(() => (get(components), deep_read_state(global())), () => {
    (($$value) => {
      set(components, $$value.components);
    })(global());
  });
  legacy_pre_effect(() => (get(markType), deep_read_state(node())), () => {
    (($$value) => {
      set(markType, $$value.markType);
    })(node());
  });
  legacy_pre_effect(() => (get(components), get(markType)), () => {
    set(markComponent, get(components).marks[get(markType)]);
  });
  legacy_pre_effect(
    () => (get(markComponent), deep_read_state(global()), get(markType)),
    () => {
      if (!get(markComponent)) {
        global().missingComponentHandler(get(markType), "mark");
      }
    }
  );
  legacy_pre_effect(
    () => (deep_read_state(global()), deep_read_state(parentBlock()), get(markType), deep_read_state(node()), spanToPlainText),
    () => {
      set(markProps, (() => {
        return {
          global: global(),
          parentBlock: parentBlock(),
          markType: get(markType),
          value: node().markDef,
          markKey: node().markKey,
          plainTextContent: spanToPlainText(node())
        };
      })());
    }
  );
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  add_svelte_meta(
    () => component(node_1, () => get(markComponent) || get(components).unknownMark, ($$anchor2, $$component) => {
      $$component($$anchor2, {
        get portableText() {
          return get(markProps);
        },
        children: wrap_snippet(RenderSpan, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          slot(node_2, $$props, "default", {}, null);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    RenderSpan,
    28,
    0,
    { componentTag: "svelte:component" }
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RenderSpan = hmr(RenderSpan);
  import.meta.hot.accept((module) => {
    RenderSpan[HMR].update(module.default);
  });
}
var RenderSpan_default = RenderSpan;

// node_modules/@portabletext/svelte/dist/renderers/RenderText.svelte
RenderText[FILENAME] = "node_modules/@portabletext/svelte/dist/renderers/RenderText.svelte";
function RenderText($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, RenderText);
  const components = mutable_source();
  const text2 = mutable_source();
  let global = prop($$props, "global", 8);
  let node = prop($$props, "node", 8);
  legacy_pre_effect(() => (get(components), deep_read_state(global())), () => {
    (($$value) => {
      set(components, $$value.components);
    })(global());
  });
  legacy_pre_effect(() => (get(text2), deep_read_state(node())), () => {
    (($$value) => {
      set(text2, $$value.text);
    })(node());
  });
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(
            () => component(node_3, () => get(components).hardBreak, ($$anchor4, $$component) => {
              $$component($$anchor4, {});
            }),
            "component",
            RenderText,
            11,
            4,
            { componentTag: "svelte:component" }
          );
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var text_1 = text();
          template_effect(() => set_text(text_1, get(text2)));
          append($$anchor3, text_1);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if (get(components), untrack(() => strict_equals(typeof get(components).hardBreak, "function"))) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          RenderText,
          10,
          2
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var text_2 = text();
      template_effect(() => set_text(text_2, get(text2)));
      append($$anchor2, text_2);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (strict_equals(get(text2), "\n")) $$render(consequent_1);
        else $$render(alternate_1, false);
      }),
      "if",
      RenderText,
      9,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RenderText = hmr(RenderText);
  import.meta.hot.accept((module) => {
    RenderText[HMR].update(module.default);
  });
}
var RenderText_default = RenderText;

// node_modules/@portabletext/svelte/dist/RenderNode.svelte
RenderNode[FILENAME] = "node_modules/@portabletext/svelte/dist/RenderNode.svelte";
function RenderNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, RenderNode);
  const node = mutable_source();
  const indexInParent = mutable_source();
  const parentBlock = mutable_source();
  const isInline = mutable_source();
  let global = prop($$props, "global", 8);
  let options = prop($$props, "options", 8);
  legacy_pre_effect(
    () => (get(node), get(indexInParent), get(parentBlock), get(isInline), deep_read_state(options())),
    () => {
      (($$value) => {
        set(node, $$value.node);
        set(indexInParent, $$value.indexInParent);
        set(parentBlock, $$value.parentBlock);
        set(isInline, $$value.isInline);
      })(options());
    }
  );
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      add_svelte_meta(
        () => RenderList_default(node_2, {
          get node() {
            return get(node);
          },
          get indexInParent() {
            return get(indexInParent);
          },
          get global() {
            return global();
          },
          children: wrap_snippet(RenderNode, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_3 = first_child(fragment_2);
            add_svelte_meta(
              () => each(node_3, 1, () => (get(node), untrack(() => get(node).children)), index, ($$anchor4, child2, childIndex) => {
                var fragment_3 = comment();
                var node_4 = first_child(fragment_3);
                {
                  let $0 = derived_safe_equal(() => ({
                    node: get(child2),
                    indexInParent: childIndex,
                    parentBlock: void 0,
                    isInline: void 0
                  }));
                  add_svelte_meta(
                    () => RenderNode(node_4, {
                      get options() {
                        return get($0);
                      },
                      get global() {
                        return global();
                      }
                    }),
                    "component",
                    RenderNode,
                    24,
                    6,
                    { componentTag: "svelte:self" }
                  );
                }
                append($$anchor4, fragment_3);
              }),
              "each",
              RenderNode,
              23,
              4
            );
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }),
        "component",
        RenderNode,
        22,
        2,
        { componentTag: "RenderList" }
      );
      append($$anchor2, fragment_1);
    };
    var d = user_derived(() => (deep_read_state(isPortableTextToolkitList), get(node), untrack(() => isPortableTextToolkitList(get(node)))));
    var consequent_1 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      add_svelte_meta(
        () => RenderListItem_default(node_5, {
          get node() {
            return get(node);
          },
          get indexInParent() {
            return get(indexInParent);
          },
          get global() {
            return global();
          },
          children: wrap_snippet(RenderNode, ($$anchor3, $$slotProps) => {
            var fragment_5 = comment();
            var node_6 = first_child(fragment_5);
            add_svelte_meta(
              () => each(
                node_6,
                1,
                () => (deep_read_state(buildMarksTree), get(node), untrack(() => buildMarksTree(get(node)))),
                index,
                ($$anchor4, child2, childIndex) => {
                  var fragment_6 = comment();
                  var node_7 = first_child(fragment_6);
                  {
                    let $0 = derived_safe_equal(() => ({
                      parentBlock: get(node),
                      node: get(child2),
                      isInline: true,
                      indexInParent: childIndex
                    }));
                    add_svelte_meta(
                      () => RenderNode(node_7, {
                        get options() {
                          return get($0);
                        },
                        get global() {
                          return global();
                        }
                      }),
                      "component",
                      RenderNode,
                      39,
                      6,
                      { componentTag: "svelte:self" }
                    );
                  }
                  append($$anchor4, fragment_6);
                }
              ),
              "each",
              RenderNode,
              38,
              4
            );
            append($$anchor3, fragment_5);
          }),
          $$slots: { default: true }
        }),
        "component",
        RenderNode,
        37,
        2,
        { componentTag: "RenderListItem" }
      );
      append($$anchor2, fragment_4);
    };
    var d_1 = user_derived(() => (deep_read_state(isPortableTextListItemBlock), get(node), untrack(() => isPortableTextListItemBlock(get(node)))));
    var consequent_2 = ($$anchor2) => {
      var fragment_7 = comment();
      var node_8 = first_child(fragment_7);
      add_svelte_meta(
        () => RenderSpan_default(node_8, {
          get node() {
            return get(node);
          },
          get parentBlock() {
            return get(parentBlock);
          },
          get global() {
            return global();
          },
          children: wrap_snippet(RenderNode, ($$anchor3, $$slotProps) => {
            var fragment_8 = comment();
            var node_9 = first_child(fragment_8);
            add_svelte_meta(
              () => each(node_9, 1, () => (get(node), untrack(() => get(node).children)), index, ($$anchor4, child2, childIndex) => {
                var fragment_9 = comment();
                var node_10 = first_child(fragment_9);
                {
                  let $0 = derived_safe_equal(() => ({
                    parentBlock: get(parentBlock),
                    node: get(child2),
                    isInline: true,
                    indexInParent: childIndex
                  }));
                  add_svelte_meta(
                    () => RenderNode(node_10, {
                      get options() {
                        return get($0);
                      },
                      get global() {
                        return global();
                      }
                    }),
                    "component",
                    RenderNode,
                    54,
                    6,
                    { componentTag: "svelte:self" }
                  );
                }
                append($$anchor4, fragment_9);
              }),
              "each",
              RenderNode,
              53,
              4
            );
            append($$anchor3, fragment_8);
          }),
          $$slots: { default: true }
        }),
        "component",
        RenderNode,
        52,
        2,
        { componentTag: "RenderSpan" }
      );
      append($$anchor2, fragment_7);
    };
    var d_2 = user_derived(() => (deep_read_state(isPortableTextToolkitSpan), get(node), untrack(() => isPortableTextToolkitSpan(get(node)))));
    var consequent_3 = ($$anchor2) => {
      var fragment_10 = comment();
      var node_11 = first_child(fragment_10);
      add_svelte_meta(
        () => RenderBlock_default(node_11, {
          get node() {
            return get(node);
          },
          get indexInParent() {
            return get(indexInParent);
          },
          get global() {
            return global();
          },
          children: wrap_snippet(RenderNode, ($$anchor3, $$slotProps) => {
            var fragment_11 = comment();
            var node_12 = first_child(fragment_11);
            add_svelte_meta(
              () => each(
                node_12,
                1,
                () => (deep_read_state(buildMarksTree), get(node), untrack(() => buildMarksTree(get(node)))),
                index,
                ($$anchor4, child2, childIndex) => {
                  var fragment_12 = comment();
                  var node_13 = first_child(fragment_12);
                  {
                    let $0 = derived_safe_equal(() => ({
                      parentBlock: get(node),
                      node: get(child2),
                      isInline: true,
                      indexInParent: childIndex
                    }));
                    add_svelte_meta(
                      () => RenderNode(node_13, {
                        get options() {
                          return get($0);
                        },
                        get global() {
                          return global();
                        }
                      }),
                      "component",
                      RenderNode,
                      68,
                      6,
                      { componentTag: "svelte:self" }
                    );
                  }
                  append($$anchor4, fragment_12);
                }
              ),
              "each",
              RenderNode,
              67,
              4
            );
            append($$anchor3, fragment_11);
          }),
          $$slots: { default: true }
        }),
        "component",
        RenderNode,
        66,
        2,
        { componentTag: "RenderBlock" }
      );
      append($$anchor2, fragment_10);
    };
    var d_3 = user_derived(() => (deep_read_state(isPortableTextBlock), get(node), untrack(() => isPortableTextBlock(get(node)))));
    var consequent_4 = ($$anchor2) => {
      var fragment_13 = comment();
      var node_14 = first_child(fragment_13);
      add_svelte_meta(
        () => RenderText_default(node_14, {
          get node() {
            return get(node);
          },
          get global() {
            return global();
          }
        }),
        "component",
        RenderNode,
        80,
        2,
        { componentTag: "RenderText" }
      );
      append($$anchor2, fragment_13);
    };
    var d_4 = user_derived(() => (deep_read_state(isPortableTextToolkitTextNode), get(node), untrack(() => isPortableTextToolkitTextNode(get(node)))));
    var consequent_5 = ($$anchor2) => {
      var fragment_14 = comment();
      var node_15 = first_child(fragment_14);
      add_svelte_meta(
        () => RenderCustomBlock_default(node_15, {
          get node() {
            return get(node);
          },
          get parentBlock() {
            return get(parentBlock);
          },
          get indexInParent() {
            return get(indexInParent);
          },
          get isInline() {
            return get(isInline);
          },
          get global() {
            return global();
          }
        }),
        "component",
        RenderNode,
        82,
        2,
        { componentTag: "RenderCustomBlock" }
      );
      append($$anchor2, fragment_14);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if (get(d)) $$render(consequent);
        else if (get(d_1)) $$render(consequent_1, 1);
        else if (get(d_2)) $$render(consequent_2, 2);
        else if (get(d_3)) $$render(consequent_3, 3);
        else if (get(d_4)) $$render(consequent_4, 4);
        else if (get(node)) $$render(consequent_5, 5);
      }),
      "if",
      RenderNode,
      21,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  RenderNode = hmr(RenderNode);
  import.meta.hot.accept((module) => {
    RenderNode[HMR].update(module.default);
  });
}
var RenderNode_default = RenderNode;

// node_modules/@portabletext/svelte/dist/warnings.js
var getTemplate = (type, prop2) => `Unknown ${type}, specify a component for it in the \`components${prop2 ? "." : ""}${prop2}\` prop`;
var getWarningMessage = (type, nodeType) => {
  switch (nodeType) {
    case "block":
      return getTemplate(`block type "${type}"`, "types");
    case "blockStyle":
      return getTemplate(`block style "${type}"`, "block");
    case "listItemStyle":
      return getTemplate(`list item style "${type}"`, "listItem");
    case "listStyle":
      return getTemplate(`list style "${type}"`, "list");
    case "mark":
      return getTemplate(`mark type "${type}"`, "marks");
    default:
      return getTemplate("type");
  }
};
function printWarning(message) {
  console.warn(message);
}

// node_modules/@portabletext/svelte/dist/PortableText.svelte
PortableText[FILENAME] = "node_modules/@portabletext/svelte/dist/PortableText.svelte";
function PortableText($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, PortableText);
  const mergedComponents = mutable_source();
  const keyedBlocks = mutable_source();
  const blocks = mutable_source();
  const missingComponentHandler = mutable_source();
  let value = prop($$props, "value", 24, () => []);
  let components = prop($$props, "components", 8);
  let context = prop($$props, "context", 24, () => ({}));
  let onMissingComponent = prop($$props, "onMissingComponent", 8, true);
  legacy_pre_effect(
    () => (mergeComponents, defaultComponents_default, deep_read_state(components())),
    () => {
      set(mergedComponents, mergeComponents(defaultComponents_default, components()));
    }
  );
  legacy_pre_effect(() => (deep_read_state(value()), assertBlockKey), () => {
    set(keyedBlocks, (Array.isArray(value()) ? value() : [value()]).map(assertBlockKey));
  });
  legacy_pre_effect(() => (nestLists, get(keyedBlocks), LIST_NEST_MODE_HTML), () => {
    set(blocks, nestLists(get(keyedBlocks), LIST_NEST_MODE_HTML));
  });
  legacy_pre_effect(
    () => (deep_read_state(onMissingComponent()), getWarningMessage, printWarning),
    () => {
      set(missingComponentHandler, (type, nodeType) => {
        if (strict_equals(onMissingComponent(), false)) {
          return;
        }
        const message = getWarningMessage(type, nodeType);
        if (strict_equals(typeof onMissingComponent(), "function")) {
          onMissingComponent()(message, { type, nodeType });
          return;
        }
        printWarning(message);
      });
    }
  );
  legacy_pre_effect_reset();
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node_1 = first_child(fragment);
  add_svelte_meta(
    () => each(node_1, 3, () => get(blocks), (node) => node._key, ($$anchor2, node, index2) => {
      var fragment_1 = comment();
      var node_2 = first_child(fragment_1);
      {
        let $0 = derived_safe_equal(() => ({
          components: get(mergedComponents),
          missingComponentHandler: get(missingComponentHandler),
          context: context(),
          ptBlocks: get(blocks),
          ptRawValue: value()
        }));
        let $1 = derived_safe_equal(() => ({
          node: get(node),
          isInline: false,
          indexInParent: get(index2)
        }));
        add_svelte_meta(
          () => RenderNode_default(node_2, {
            get global() {
              return get($0);
            },
            get options() {
              return get($1);
            }
          }),
          "component",
          PortableText,
          32,
          2,
          { componentTag: "RenderNode" }
        );
      }
      append($$anchor2, fragment_1);
    }),
    "each",
    PortableText,
    31,
    0
  );
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  PortableText = hmr(PortableText);
  import.meta.hot.accept((module) => {
    PortableText[HMR].update(module.default);
  });
}
var PortableText_default = PortableText;
export {
  DefaultBlock_default as DefaultBlock,
  DefaultList_default as DefaultList,
  DefaultListItem_default as DefaultListItem,
  DefaultMark_default as DefaultMark,
  PortableText_default as PortableText,
  toPlainText
};
//# sourceMappingURL=@portabletext_svelte.js.map
